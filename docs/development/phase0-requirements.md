# Phase 0: PoC開発要件定義書

**プロジェクト名:** オーナー体験価値最大化プラットフォーム  
**フェーズ:** Phase 0（PoC: Proof of Concept）  
**期間:** 3ヶ月（2025年12月1日 〜 2026年2月28日）  
**予算:** ¥50,000,000  
**目的:** 技術的実現性とユーザー受容性の検証

---

## エグゼクティブサマリー

### **Phase 0の目標**

```
【検証すべき4つの仮説】

仮説1: 技術的実現性
  内容: RAGシステムで正確な回答ができるか
  成功基準: 回答精度 ≥ 80%、応答時間 < 3秒
  測定方法: 100問の評価データセット、人間評価

仮説2: ユーザー受容性
  内容: プロアクティブ配信でユーザーは満足するか
  成功基準: ユーザー満足度 ≥ 80%、通知開封率 ≥ 60%
  測定方法: アンケート（n=50）、アプリログ分析

仮説3: 機能活用率向上とデータドリブン開発
  内容: 
    a) 機能活用率が向上するか（ユーザー価値）
    b) 使われない機能を特定できるか（開発効率）
  成功基準: 
    a) 機能活用率 +10%以上
    b) 5機能すべてで利用パターンを分類
  測定方法: 車両データ分析、アプリログ分析

仮説4: 問い合わせ削減の可能性（定性評価）
  内容: 将来的な問い合わせ削減の可能性を示唆できるか
  成功基準: 
    - 「自己解決できた」経験率 ≥ 60%
    - 「今後減る」回答率 ≥ 70%
  測定方法: アンケート、エピソード収集

【Phase 1以降で検証する仮説】
仮説5: コールセンター入電削減（定量評価）→ Phase 1（1,000名、6ヶ月）
仮説6: ロードサービス削減（定量評価）→ Phase 2（10,000名、1年）

【成果物】
- 動作するプロトタイプ
- ユーザーテスト結果（n=50）
- 5機能の利用パターン分析レポート
- 問い合わせ削減の可能性を示唆するエピソード集
- Phase 1詳細計画書
- ROI試算（実データベース）
```

---

## 1. 開発要件の全体像

### **1.1 スコープ**

#### **対象車種**
- Lexus NX 450h+ （1車種のみ）
- 理由: 
  - 人気車種（販売台数が多い）
  - 機能が豊富（100以上）
  - ハイブリッドで先進機能搭載

#### **対象ユーザー**
- 50名（ターゲット）
  - 新規オーナー: 30名（納車後1ヶ月以内）
  - 既存オーナー: 20名（納車後3-6ヶ月）
- 条件:
  - スマートフォン所有
  - アプリインストール可能
  - フィードバック提供に協力的

#### **対象機能**
- 5つの主要シナリオのみ
  1. 雨天時のワイパー案内
  2. 高速道路進入時のクルーズコントロール案内
  3. 駐車時のパーキングアシスト案内
  4. エンジン始動時の基本機能紹介
  5. 警告灯点灯時のトラブルシューティング

---

## 2. 機能要件

### **2.1 RAGシステム（情報提供の仕組み）**

#### **2.1.1 取扱説明書のデジタル化**

**入力:**
- Lexus NX 450h+ 取扱説明書（PDF、500ページ）

**処理:**
```
1. PDF → テキスト抽出
   - OCR不要（元々デジタルPDF）
   - フォーマット保持（見出し、リスト等）

2. セクション分割
   - 章ごとに分割（第1章、第2章...）
   - 機能ごとにさらに分割（ワイパー、エアコン...）

3. チャンク化
   - 1チャンク = 500-1000トークン
   - 前後のコンテキストを保持
   - 重複を許容（検索精度向上のため）

4. メタデータ付与
   {
     "chunk_id": "nx_wiper_001",
     "vehicle": "NX 450h+",
     "category": "基本操作",
     "function": "ワイパー",
     "page": 123,
     "importance": "high",
     "difficulty": "beginner"
   }

5. ベクトル化
   - モデル: OpenAI text-embedding-3-large
   - 次元数: 3072
   - 言語: 日本語
```

**出力:**
- ベクトル化されたチャンク（約1,000個）
- メタデータ付きインデックス

**品質基準:**
- チャンク数: 800-1,200個
- 平均チャンクサイズ: 500-1,000トークン
- 重複チャンク率: < 5%
- メタデータ完全性: 100%

---

#### **2.1.2 ベクトルデータベース構築**

**技術選定:**
- Pinecone（推奨）
  - 理由: マネージドサービス、高速、スケーラブル
  - 代替: Weaviate、Qdrant

**設定:**
```python
# Pinecone Index設定
{
  "name": "lexus-manual-poc",
  "dimension": 3072,
  "metric": "cosine",
  "pod_type": "p1.x1",  # Phase 0は最小構成
  "replicas": 1,
  "shards": 1
}
```

**データ投入:**
```python
# 擬似コード
for chunk in chunks:
    vector = embed(chunk.text)
    pinecone.upsert(
        id=chunk.id,
        vector=vector,
        metadata=chunk.metadata
    )
```

**品質基準:**
- 投入完了時間: < 1時間
- インデックス構築時間: < 10分
- 検索レスポンス: < 500ms

---

#### **2.1.3 RAG検索・回答生成**

**入力:**
- ユーザー質問（テキスト）

**処理フロー:**
```
1. 質問のベクトル化
   question_vector = embed(user_question)

2. 類似チャンク検索（Hybrid Search）
   a. ベクトル検索
      - Top 10を取得
      - cosine similarity > 0.7
   
   b. キーワード検索（補助）
      - 固有名詞（機能名、部品名）
      - エラーコード
   
   c. フィルタリング
      - 車種: NX 450h+
      - 難易度: ユーザーレベルに応じて

3. コンテキスト構築
   context = format_chunks(retrieved_chunks)

4. LLMで回答生成
   prompt = f"""
   あなたはLexusの専門家です。
   以下の情報を元に、ユーザーの質問に回答してください。
   
   【質問】
   {user_question}
   
   【参考情報】
   {context}
   
   【回答の条件】
   - わかりやすく、具体的に
   - 取扱説明書のページ番号を明示
   - 安全に関わる場合は注意喚起
   """
   
   answer = llm.generate(prompt)

5. 回答の後処理
   - ページ番号のリンク化
   - 画像・動画の添付（あれば）
   - 関連する機能の提案
```

**出力:**
```json
{
  "answer": "ワイパーはハンドル右側のレバーで操作します。上に動かすと...",
  "confidence": 0.92,
  "source": "取扱説明書 P.123-124",
  "related_functions": ["オートワイパー", "ウォッシャー"],
  "response_time_ms": 1850
}
```

**品質基準:**
- 回答精度: 80%以上（人間評価）
- 回答時間: < 3秒
- 回答の完全性: 90%以上
- ユーザー満足度: 80%以上

---

### **2.2 データ収集基盤（行動理解の仕組み）**

#### **2.2.1 車両データ収集**

**対象車両:**
- 5台のLexus NX 450h+
- 協力ディーラーから貸与またはモニター募集

**収集データ:**

| データ種別 | 項目 | 頻度 | データ量 |
|-----------|------|------|---------|
| **位置情報** | GPS座標、速度、方向 | 1秒 | 約100KB/日 |
| **車両状態** | エンジン状態、ギア、燃料 | 10秒 | 約50KB/日 |
| **機能利用** | どの機能をON/OFF | イベント発生時 | 約10KB/日 |
| **エラーログ** | 警告灯、エラーコード | イベント発生時 | 約5KB/日 |
| **環境データ** | 外気温、天気（API） | 10分 | 約1KB/日 |

**収集方法:**

```
【方法A: OBD-IIドングル（推奨）】
- デバイス: OBDLink MX+ または同等品
- 接続: Bluetooth → スマホアプリ
- データ: CAN Busから取得
- コスト: ¥15,000/台 × 5台 = ¥75,000

【方法B: 車載システム連携】
- トヨタコネクティッドAPIを使用
- 制約: データ種別が限定的
- コスト: API利用料
```

**データパイプライン:**
```
車両（OBD-II）
  ↓ Bluetooth
スマホアプリ
  ↓ HTTPS（暗号化）
AWS Kinesis Data Streams
  ↓
Lambda（リアルタイム処理）
  ↓
S3（ローデータ保存）+ DynamoDB（メタデータ）
```

**品質基準:**
- データ収集成功率: > 95%
- 遅延: < 10秒（リアルタイムデータ）
- データ欠損率: < 5%

---

#### **2.2.2 外部データ統合**

**天気API:**
```python
# OpenWeatherMap API
response = requests.get(
    "https://api.openweathermap.org/data/2.5/weather",
    params={
        "lat": gps_lat,
        "lon": gps_lon,
        "appid": API_KEY,
        "lang": "ja"
    }
)

weather_data = {
    "condition": response.json()["weather"][0]["main"],  # "Rain", "Clear"
    "temperature": response.json()["main"]["temp"],
    "humidity": response.json()["main"]["humidity"]
}
```

**地図API:**
```python
# Google Maps API
# 道路種別（一般道 or 高速道路）を判定
response = requests.get(
    "https://maps.googleapis.com/maps/api/roads/nearestRoads",
    params={
        "points": f"{gps_lat},{gps_lon}",
        "key": API_KEY
    }
)

road_type = classify_road(response.json())  # "highway" or "local"
```

**品質基準:**
- API応答時間: < 1秒
- API成功率: > 99%
- コスト: 月額¥10,000以内

---

#### **2.2.3 予測アルゴリズム（ルールベース）**

**Phase 0では機械学習は使わず、シンプルなルールベースで実装**

**シナリオ1: 雨天時のワイパー案内**
```python
def check_wiper_scenario(vehicle_data, weather_data, user_profile):
    """
    雨が降っているのにワイパーを使っていない場合に通知
    """
    # 条件チェック
    is_raining = weather_data["condition"] == "Rain"
    wiper_off = vehicle_data["wiper_status"] == "OFF"
    is_driving = vehicle_data["speed"] > 10  # 10km/h以上
    never_used_auto_wiper = not user_profile.get("auto_wiper_used", False)
    
    # トリガー判定
    if is_raining and wiper_off and is_driving and never_used_auto_wiper:
        return {
            "trigger": True,
            "scenario": "wiper_in_rain",
            "priority": "high",
            "message": "雨が降り始めました。オートワイパーをONにしますか？",
            "action": "show_wiper_guide"
        }
    
    return {"trigger": False}
```

**シナリオ2: 高速道路進入時のクルーズコントロール案内**
```python
def check_cruise_control_scenario(vehicle_data, road_data, user_profile):
    """
    高速道路に入った時にクルーズコントロールを提案
    """
    # 条件チェック
    entered_highway = (
        road_data["prev_road_type"] == "local" and
        road_data["current_road_type"] == "highway"
    )
    cruise_off = vehicle_data["cruise_control"] == "OFF"
    speed_stable = vehicle_data["speed"] > 60  # 60km/h以上
    never_used = not user_profile.get("cruise_control_used", False)
    
    # トリガー判定
    if entered_highway and cruise_off and speed_stable and never_used:
        return {
            "trigger": True,
            "scenario": "cruise_on_highway",
            "priority": "medium",
            "message": "高速道路に入りました。レーダークルーズコントロールを使うと楽ですよ。",
            "action": "show_cruise_guide"
        }
    
    return {"trigger": False}
```

**シナリオ3-5も同様にルールベースで実装**

**品質基準:**
- 誤検知率: < 10%（間違った通知）
- 見逃し率: < 20%（通知すべきなのにしない）
- 反応時間: < 5秒（条件成立から通知まで）

---

### **2.3 プロアクティブ配信システム（統合）**

#### **2.3.1 通知配信エンジン**

**通知の優先度管理:**
```python
PRIORITY_LEVELS = {
    "critical": {  # 安全に関わる
        "score": 100,
        "interrupt": True,  # 運転中でも表示
        "expire": 60  # 60秒以内に対応必須
    },
    "high": {  # 重要だが緊急ではない
        "score": 70,
        "interrupt": False,
        "expire": 300  # 5分以内
    },
    "medium": {  # 便利な提案
        "score": 40,
        "interrupt": False,
        "expire": 3600  # 1時間以内
    },
    "low": {  # 参考情報
        "score": 10,
        "interrupt": False,
        "expire": 86400  # 24時間以内
    }
}
```

**通知頻度制御:**
```python
# 同じ通知を短時間に繰り返さない
NOTIFICATION_COOLDOWN = {
    "same_scenario": 3600,  # 同じシナリオは1時間に1回まで
    "any_scenario": 300,    # 何らかの通知は5分に1回まで
    "per_day": 10           # 1日10回まで
}
```

**通知内容の生成:**
```python
def generate_notification(scenario, user_profile, vehicle_data):
    """
    シナリオに応じた通知を生成（RAGと連携）
    """
    # 1. RAGで関連情報を取得
    query = f"{scenario['function']}の使い方"
    rag_result = rag_search(query)
    
    # 2. ユーザーレベルに応じて内容を調整
    if user_profile["experience_level"] == "beginner":
        detail_level = "detailed"
    else:
        detail_level = "brief"
    
    # 3. LLMで通知文を生成
    notification = {
        "title": scenario["message"],
        "body": rag_result["answer"],
        "image": get_ar_image(scenario["function"]),
        "actions": [
            {"label": "試してみる", "action": "start_guide"},
            {"label": "後で", "action": "snooze"},
            {"label": "今後表示しない", "action": "disable"}
        ],
        "priority": scenario["priority"]
    }
    
    return notification
```

**配信チャネル:**
```
Phase 0ではスマホアプリのみ

【通知タイプ】
1. プッシュ通知（ロック画面）
   - 緊急性が高い場合
   
2. アプリ内通知（バナー）
   - アプリ使用中
   
3. 通知センター
   - 後で見られる
```

**品質基準:**
- 通知到達率: > 95%
- 通知遅延: < 10秒
- 誤配信率: < 1%
- ユーザーによる無効化率: < 30%

---

### **2.4 スマホアプリ（フロントエンド）**

#### **2.4.1 基本仕様**

**対応プラットフォーム:**
- iOS 15以上
- Android 10以上

**開発技術:**
- Flutter（クロスプラットフォーム）
- 理由: 1つのコードベースでiOS/Android両対応

**主要画面:**

```
【画面1: ホーム】
- 車両ステータス表示
- 最新の通知一覧
- 機能学習進捗（バッジ）

【画面2: 通知詳細】
- 通知内容
- 関連する取扱説明書（リンク）
- 動画・AR案内（あれば）
- アクションボタン

【画面3: 質問（RAG検索）】
- 検索ボックス
- よくある質問
- 検索履歴

【画面4: プロフィール】
- ユーザー情報
- 学習済み機能
- 通知設定

【画面5: ガイド（体験型学習）】
- ステップバイステップの案内
- AR表示（カメラオーバーレイ）
- 完了チェック
```

#### **2.4.2 AR機能（最小限）**

**使用技術:**
- ARCore（Android）
- ARKit（iOS）

**実装範囲:**
```
Phase 0では静的なオーバーレイのみ
- 車両の3Dモデルは使わない
- カメラ映像に矢印・テキストを重ねる程度

例: ワイパーレバーを示す矢印を表示
```

**品質基準:**
- AR起動時間: < 3秒
- フレームレート: > 30fps
- 位置精度: ±5cm程度

---

## 3. 非機能要件

### **3.1 パフォーマンス**

| 項目 | 基準 |
|-----|------|
| RAG応答時間 | < 3秒 |
| データ収集遅延 | < 10秒 |
| 通知配信遅延 | < 10秒 |
| アプリ起動時間 | < 2秒 |
| 同時ユーザー数 | 50人（Phase 0） |

### **3.2 可用性**

| 項目 | 基準 |
|-----|------|
| システム稼働率 | > 95%（Phase 0は緩め） |
| データ損失 | 0件 |
| ダウンタイム | 週1時間まで許容（メンテナンス） |

### **3.3 セキュリティ**

```
【データ暗号化】
- 通信: TLS 1.3
- 保存: AES-256

【認証】
- OAuth 2.0
- トークンの有効期限: 1時間

【個人情報保護】
- GPS座標の丸め（100m単位）
- 車両IDの匿名化
- ユーザー同意の取得（オプトイン）

【アクセス制御】
- ユーザーは自分のデータのみ閲覧可能
- 開発チームは匿名化されたデータのみ閲覧
```

### **3.4 スケーラビリティ**

```
Phase 0: 50人
Phase 1: 10,000人に拡張可能な設計

【設計方針】
- マイクロサービスアーキテクチャ
- ステートレスなAPI
- 水平スケーリング可能
```

---

## 4. 技術スタック

### **4.1 バックエンド**

| 領域 | 技術 | 理由 |
|------|------|------|
| **API** | Python + FastAPI | 高速、非同期、型安全 |
| **RAG** | LangChain + OpenAI | 実績、コミュニティ |
| **LLM** | GPT-4 Turbo | 日本語性能、コスト |
| **ベクトルDB** | Pinecone | マネージド、高速 |
| **データ収集** | AWS Kinesis | リアルタイムストリーム |
| **DB** | PostgreSQL | リレーショナルデータ |
| **キャッシュ** | Redis | 高速、セッション管理 |
| **ストレージ** | AWS S3 | ローデータ保存 |
| **インフラ** | AWS（ECS） | スケーラブル |

### **4.2 フロントエンド**

| 領域 | 技術 | 理由 |
|------|------|------|
| **アプリ** | Flutter | クロスプラットフォーム |
| **状態管理** | Riverpod | シンプル、型安全 |
| **AR** | ARCore/ARKit | ネイティブ性能 |
| **通知** | Firebase Cloud Messaging | 信頼性高い |

### **4.3 開発ツール**

| 領域 | 技術 |
|------|------|
| **バージョン管理** | Git + GitHub |
| **CI/CD** | GitHub Actions |
| **監視** | CloudWatch + Sentry |
| **ログ** | CloudWatch Logs |
| **プロジェクト管理** | Notion or Jira |

---

## 5. 開発体制

### **5.1 チーム構成**

```
合計: 10名

【コアチーム】
- PM: 1名（プロジェクト管理、要件定義）
- テックリード: 1名（技術選定、アーキテクチャ）

【バックエンド】
- AI/MLエンジニア: 2名（RAG、予測アルゴリズム）
- バックエンドエンジニア: 1名（API、データパイプライン）

【フロントエンド】
- Flutterエンジニア: 2名（アプリ開発）
- UI/UXデザイナー: 1名（画面設計、ユーザビリティ）

【その他】
- QA: 1名（テスト、品質管理）
- データサイエンティスト: 1名（データ分析、評価）
```

### **5.2 役割分担**

| 役割 | 担当範囲 | 工数 |
|------|---------|------|
| **PM** | 要件定義、進捗管理、ステークホルダー調整 | 100% |
| **テックリード** | アーキテクチャ設計、技術選定、コードレビュー | 80% |
| **AI/MLエンジニア** | RAG実装、予測アルゴリズム、評価 | 100% |
| **バックエンド** | API開発、データパイプライン、インフラ | 100% |
| **フロントエンド** | アプリ開発、UI実装 | 100% |
| **UI/UX** | 画面設計、ユーザーテスト設計 | 80% |
| **QA** | テストケース作成、品質保証 | 100% |
| **データサイエンティスト** | 効果測定、分析 | 50% |

---

## 6. 開発スケジュール

### **6.1 全体スケジュール（3ヶ月）**

```
【Month 1: 設計・開発準備（2025年12月）】
Week 1: 
- キックオフ
- 要件詳細化
- 技術調査

Week 2-4:
- アーキテクチャ設計
- データベース設計
- API設計
- UI/UX設計

【Month 2: 実装（2026年1月）】
Week 5-8:
- RAGシステム実装
- データ収集基盤実装
- 予測アルゴリズム実装
- アプリ実装（並行）

【Month 3: テスト・検証（2026年2月）】
Week 9-10:
- 統合テスト
- 内部テスト（チーム）

Week 11-12:
- ユーザーテスト（50人）
- データ分析
- Phase 1計画策定

Week 13:
- 最終報告書作成
- 社長報告
```

### **6.2 詳細スケジュール**

| Week | バックエンド | フロントエンド | その他 |
|------|------------|--------------|--------|
| **1** | 技術調査、環境構築 | 技術調査、環境構築 | キックオフ、要件整理 |
| **2** | DB設計、API設計 | UI/UX設計 | データ準備（取扱説明書） |
| **3-4** | RAG実装開始 | アプリ基盤実装 | モニター募集 |
| **5-6** | RAG完成、データ収集実装 | 画面実装 | - |
| **7-8** | 予測アルゴリズム、統合 | AR実装、統合 | - |
| **9-10** | バグ修正、最適化 | バグ修正、最適化 | テストケース作成 |
| **11-12** | 運用準備 | 運用準備 | ユーザーテスト実施 |
| **13** | - | - | 報告書作成 |

---

## 7. 評価方法

### **7.1 ユーザーテスト設計**

**対象者:**
- 50名のLexus NXオーナー
- 新規オーナー30名、既存オーナー20名

**期間:**
- 2週間（実際の使用）

**評価項目:**

```
【定量評価】

1. 仮説1: 技術的実現性
   - RAG回答精度: 100問の評価データセット
   - 応答時間: 平均応答時間
   - 目標: 精度 ≥ 80%、応答時間 < 3秒

2. 仮説2: ユーザー受容性
   - ユーザー満足度（アンケート）
     - システム有用性: 1-5点
     - 情報の正確性: 1-5点
     - 使いやすさ: 1-5点
     - 通知の適切さ: 1-5点
     - 総合満足度: 1-5点
   - 通知開封率
   - 目標: 満足度 ≥ 80%、開封率 ≥ 60%

3. 仮説3a: 機能活用率向上
   - テスト前: ベースライン測定
   - テスト後: 改善度を測定
   - 目標: +10%以上

4. 仮説3b: 開発効率向上
   - 5機能の利用パターン分類
     - パターンA: 継続利用（価値あり）
     - パターンB: 1回きり（価値不明）
     - パターンC: 通知無視（価値なし or タイミング悪い）
     - パターンD: 通知は見たが利用せず（価値なし）
   - 機能ごとの集計
     - 通知配信数、開封数、利用数、継続利用数
   - 目標: 5機能すべてで利用パターン分類完了

【定性評価】

5. 仮説4: 問い合わせ削減の可能性
   - アンケート項目:
     Q1: このシステムを使う前の解決方法
     Q2: 「コールセンターに電話しようと思ったが、
          アプリで解決できた」経験の有無と回数
     Q3: 具体的なエピソード（自由記述）
     Q4: 今後コールセンターに電話する回数は減ると思うか
     Q5: このシステムで解決できなかった問題
   - 目標: 
     - 「自己解決できた」経験率 ≥ 60%
     - 「今後減る」回答率 ≥ 70%
     - 具体的なエピソード 30件以上収集

6. インタビュー（10名）
   - 良かった点
   - 改善点
   - 要望

7. 自由記述アンケート
   - 印象に残った体験
   - 困った点
   - 提案
```

### **7.2 技術的評価**

```
【RAGシステム】
1. 回答精度
   - 評価データセット: 100問
   - 人間評価（正確/不正確）
   - 目標: 80%以上

2. 回答時間
   - 平均応答時間
   - 目標: < 3秒

【予測システム】
1. トリガー精度
   - 正検知率: 目標 80%以上
   - 誤検知率: 目標 10%以下

2. タイミング
   - 適切なタイミングでの通知: 目標 70%以上
```

### **7.3 成功基準（Go/No-Go判断）**

```
【Phase 1へ進む条件】

必須条件（すべて満たす必要）:
✅ 仮説1（技術的実現性）: 回答精度 ≥ 80%、応答時間 < 3秒
✅ 仮説2（ユーザー受容性）: 満足度 ≥ 80%、通知開封率 ≥ 60%

ビジネス価値条件（いずれか1つ以上）:
✅ 仮説3a（機能活用率）: +10%以上
✅ 仮説3b（開発効率）: 5機能すべてで利用パターン分類完了
✅ 仮説4（問い合わせ削減可能性）: 
   - 「自己解決できた」≥ 60%
   - 「今後減る」≥ 70%

理想的な結果:
- 仮説1-2: 成功
- 仮説3a-b: 成功
- 仮説4: 成功（定性評価で可能性を示唆）
→ Phase 1で仮説5-6（コールセンター・ロードサービス削減）を定量評価

【中止条件（1つでも該当）】
❌ 仮説1-2が成功基準を満たさない
❌ 技術的に実現不可能と判明
❌ コスト超過（予算の150%超）
❌ 致命的なセキュリティリスク発見
```

---

## 8. 予算内訳

```
【総予算】¥50,000,000

【内訳】
1. 人件費: ¥35,000,000（70%）
   - 10名 × 3ヶ月 × 平均月額¥1,166,000

2. インフラ・ツール: ¥8,000,000（16%）
   - AWS: ¥3,000,000
   - OpenAI API: ¥2,000,000
   - Pinecone: ¥500,000
   - その他ツール: ¥2,500,000

3. ハードウェア: ¥2,000,000（4%）
   - OBD-IIドングル: ¥75,000
   - テスト用デバイス: ¥1,000,000
   - その他: ¥925,000

4. 外部委託: ¥3,000,000（6%）
   - UI/UXデザイン: ¥1,500,000
   - 動画制作: ¥1,000,000
   - その他: ¥500,000

5. その他: ¥2,000,000（4%）
   - 予備費、雑費
```

---

## 9. リスク管理

### **9.1 技術的リスク**

| リスク | 確率 | 影響 | 対策 |
|-------|------|------|------|
| **RAGの回答精度が低い** | 中 | 大 | ・プロンプトエンジニアリング<br>・チャンク化の最適化<br>・人間によるレビュー |
| **データ収集が不安定** | 中 | 中 | ・複数の収集方法を用意<br>・エラーハンドリング強化 |
| **予測の誤検知が多い** | 高 | 中 | ・閾値の調整<br>・ユーザーフィードバックで改善 |
| **アプリのクラッシュ** | 低 | 中 | ・十分なテスト<br>・クラッシュレポート導入 |

### **9.2 ユーザー受容性リスク**

| リスク | 確率 | 影響 | 対策 |
|-------|------|------|------|
| **通知がうるさいと感じる** | 高 | 大 | ・頻度制限<br>・ユーザー設定で調整可能に |
| **プライバシー懸念** | 中 | 大 | ・透明性の確保<br>・データ利用の説明 |
| **使い方がわからない** | 中 | 中 | ・オンボーディング強化<br>・ヘルプ充実 |

### **9.3 スケジュールリスク**

| リスク | 確率 | 影響 | 対策 |
|-------|------|------|------|
| **開発遅延** | 中 | 中 | ・週次進捗確認<br>・スコープ調整 |
| **モニター確保困難** | 低 | 大 | ・早期募集開始<br>・インセンティブ提供 |
| **メンバーの離脱** | 低 | 大 | ・バックアッププラン<br>・ドキュメント整備 |

---

## 10. 成果物

### **10.1 システム成果物**

```
【1. 動作するプロトタイプ】
- バックエンド（API）
- フロントエンド（iOS/Androidアプリ）
- RAGシステム
- データ収集基盤
- 予測アルゴリズム

【2. ドキュメント】
- システム設計書
- API仕様書
- データベース設計書
- 運用マニュアル
- テスト仕様書

【3. データ】
- ベクトル化された取扱説明書
- 収集された車両データ（2週間分）
- ユーザーフィードバックデータ
```

### **10.2 評価成果物**

```
【1. ユーザーテスト結果報告書】
- 定量評価結果（仮説1-3）
- 定性評価結果（仮説4）
- インタビュー要約
- 改善提案

【2. 技術評価報告書】
- RAG精度評価
- 予測精度評価
- パフォーマンス測定結果
- 技術的課題と解決策

【3. 機能利用パターン分析レポート（新規）】
- 5機能の利用パターン分類
  - パターンA: 継続利用（価値あり）
  - パターンB: 1回きり（価値不明）
  - パターンC: 通知無視（価値なし or タイミング悪い）
  - パターンD: 通知は見たが利用せず（価値なし）
- 機能ごとの詳細データ
  - 通知配信数、開封数、利用数、継続利用数
- 開発側への改善提案
- 次期モデルへの機能優先順位提案

【4. 問い合わせ削減の可能性を示唆するエピソード集（新規）】
- 「自己解決できた」具体的なエピソード（30件以上）
- 解決できなかった問題の分析
- Phase 1での定量評価への示唆

【5. Phase 1詳細計画書】
- 要件定義（仮説5-6の定量評価を含む）
- 開発スケジュール
- 予算計画
- リスク管理計画

【6. ROI試算書】
- Phase 0でのコスト分析
- Phase 0で測定できた価値（仮説3b: 開発効率）
- Phase 1での期待効果（仮説5: コールセンター削減）
- Phase 2での期待効果（仮説6: ロードサービス削減）
- 投資回収期間
- Phase 1の判断根拠
```

---

## 11. Phase 1への移行条件

### **11.1 技術的条件**

```
✅ RAG回答精度 ≥ 80%
✅ システム稼働率 ≥ 95%
✅ 重大なバグなし
✅ スケーラビリティの確認
```

### **11.2 ビジネス的条件**

```
✅ ユーザー満足度 ≥ 80%
✅ 機能活用率改善 ≥ 10%
✅ 開発効率向上の可能性を確認（利用パターン分析完了）
✅ 問い合わせ削減の可能性を示唆（定性評価で60%以上）
✅ ROI見込み ≥ 5倍（Phase 1-2での期待効果を含む）
✅ 経営層の承認
```

### **11.3 Phase 1での拡張計画**

```
【スケール】
Phase 0: 50人、2週間 → Phase 1: 1,000人、6ヶ月

【検証内容の拡張】
Phase 0で示唆された仮説を定量評価:
- 仮説5: コールセンター入電削減（定量評価）
  - コールセンターログ連携（Phase 1で実装）
  - 期待削減率: 30%
  - 期待効果: 2,000万円/年（1,000名）
  
- 仮説3b: 開発効率向上（拡大）
  - 全機能の利用パターン分析
  - 次期モデルへの機能優先順位決定
  - 期待効果: 5,000万円/年

【機能拡張】
- 全Lexus車種対応
- 100シナリオの予測
- 車載システム統合
- ARの高度化
- コミュニティ機能

【技術進化】
- ルールベース → 機械学習
- 5シナリオ → 100シナリオ
- 1車種 → 全車種

【Phase 2での展開】
Phase 1: 1,000人、6ヶ月 → Phase 2: 10,000人、1年
- 仮説6: ロードサービス削減（定量評価）
  - 期待削減率: 20%
  - 期待効果: 2,600万円/年
- 全仮説の大規模検証
- 合計ROI: 7.26億円/年
```

---

## 付録A: 技術調査項目（Week 1）

```
【RAG関連】
- LLM選定（GPT-4 vs Claude vs Gemini）
- ベクトルDB比較（Pinecone vs Weaviate vs Qdrant）
- Embeddingモデル比較
- チャンキング戦略

【データ収集】
- OBD-IIドングル選定
- トヨタコネクティッドAPI調査
- 代替データ収集方法

【インフラ】
- AWS vs GCP vs Azure
- コスト試算
- セキュリティ要件
```

---

## 付録B: 開発環境

```
【開発環境】
- OS: macOS / Windows / Linux
- IDE: VSCode
- Python: 3.11
- Flutter: 3.16

【ステージング環境】
- AWS ECS（開発用）
- PostgreSQL（RDS）
- Redis（ElastiCache）

【本番環境（Phase 0用）】
- AWS ECS（本番用、最小構成）
- ユーザー: 50人
- スケール: 後で拡張可能
```

---

**この要件定義書は、Phase 0開発の完全な設計図です。**
**この通りに実装すれば、3ヶ月で検証可能なプロトタイプが完成します。**







